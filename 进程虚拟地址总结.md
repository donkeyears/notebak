# 进程虚拟地址总结

## 1.虚拟地址存在的原因

按照最原始的想法，内存可以这样分配。如果有a，b两个进程，a占用100M，b占用20M。那么可以依次把他们调入内存。但是这样有一些问题。

- 地址空间不隔离，会有进程之间相互干扰，风险很大。比如a进程可以读取b进程的内容
- 内存效率低，假设现在总的内存不大，已经ab占满，那么这时候在调用c就很麻烦了。、
- 程序运行地址不稳定。由于a，b进入的顺序不确定。因此每次a运行的时候都会有不同的地址。

为了解决这些问题，慢慢出了虚拟地址。由操作系统管理一个虚拟地址解决。

## 2.虚拟地址介绍

虚拟地址是由操作系统管理的。在32bits系统下，任何一个进程在运行时被分配4GB的内存，这个内存是虚拟内存，但是和实际物理内存有一定的映射关系，这个映射关系由操作系统去负责。

虚拟地址的高位是内核空间，这部分是不可读不可写的。在windows下这部分占2GB，在linux下位1GB。在特殊情况下windows内核空间也可以占用1GB。

虚拟内存的低位就是用户空间，这部分从低地址往高地址一般为程序的可执行文件代码ELF，静态变量区，未初始化静态变量，堆等。然后上半部分位栈区。堆由用户自己申请释放，比如new malloc。而栈区由系统管理，存放函数调用堆栈，由函数帧组成，每个函数帧是这层调用函数的现场保护。

用户空间中堆栈的初始地址一般会有一个随机偏移，以防程序调用的地址被摸出规律吧。

在用户态的栈区一般小于8MB，如果超出了大小就会出现段错误，即segament  fault。当然有时stack'的大小是可变的，这时候会超出8MB。但是此时乱读会出问题。

在栈区下边会有一个memory mapping segment。这个区域是内核把文件映射进来。把一些动态链接库或者文件等映射进来。应用可以通过系统调用来把外部文件映射进来。对于linux是mmap（），对于windows是 CreateFileMapping() / MapViewOfFile() 。在这儿不仅可以map动态链接库，还可以链接匿名数据，比如malloc申请大于128KB的数据的时候，不用heap区，而是再次进行一个匿名调用。

堆区如果大小容易满足直接程序就可以了。但是如果过大则会需要系统内核进入处理，堆分配是一个很复杂的算法，耗时是不确定的。对于实时操作系统需要进行特殊处理。

下面到了数据段，有BSS，data，text区。前二者为静态变量全局变量。bss未初始化，

> [Program memory](https://manybutfinite.com/post/anatomy-of-a-program-in-memory/)

